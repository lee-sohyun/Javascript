# Garbage Collection

>메모리 생존주기
>: 필요할 때 할당 - 사용 (읽기, 쓰기) - 필요없어지면 해제
>
>메모리 참조
>: 메모리 관리 관점에서, 어떤 객체가 다른 객체에 접근할 수 있으면 참조한다고 한다.

### #Garbage collection
: 모든 객체들을 모니터링 하며, 접근 불가능하게 되었을 때 삭제하는 작업을 수행. 외부에서 접근 불가능한, 자기들끼리만 상호 참조하여 만들어진 완벽한 형태의 섬도 메모리에서 삭제 가능

#### 1. Reference-counting
: '더이상 필요없는 객체', '아무도 참조하지않는 객체'에 대해 가비지 컬렉션을 수행한다.

*순환 참조 때문에 생기는 문제?*

두 객체가 생성되고 서로를 참조할 때 순환참조가 생성된다. 이 객체들은 함수 호출 뒤에 스코프를 벗어나게 되므로 실질적으로는 쓸모가 없게 되고 이들이 차지하던 메모리는 반환될 수 있지만, 참조횟수계산 알고리즘(Reference-counting)에서는 두 객체가 적어도 한 번은 참조한 것으로 간주하므로 둘 다 가비지컬렉션 될 수 없다.

#### 2. Mark-and-sweep
: 해당 객체에 닿을 수 있는지 확인 후 가비지 컬렉션을 수행한다.
- 루트(roots): 코드에서 참조되는 전역 변수
- 모든 루트와 그 하위 객체들을 검사해서 활성화 상태 표시
- 활성화되지않은 객체들 정리

*이 경우 순환참조 문제 해결*

### #메모리누수
: 더이상 사용되지 않음에도 불구하고, 운영체제나 사용가능한 메모리 풀에 반환되지 않는 메모리.

#### 1. 우발적으로 생성된 전역변수
  1) 선언되지 않은 변수는 global 객체(window) 내부에 새로운 변수로 생성된다.
  2) this 또한 window global 객체를 가리킨다.
  `'use strict';`를 추가하면 우발적인 전역객체 생성을 방지하도록 해준다.
  필요에 의해 명시적으로 선언한 전역변수의 경우, 사용 후 반드시 null로 처리하거나 재할당해야한다.
  
#### 2. 잊혀진 타이머와 콜백

#### 3. DOM 외부에서의 참조
DOM 요소에 대한 참조는 트리와 맵, 두군데에서 유지되기 때문에 지워야할 경우 두 참조 모두 제거해야한다.

#### 4. 클로저
